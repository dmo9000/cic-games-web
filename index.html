<!doctype html>

<html>

  <head>

    <title>CIC Games</title>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Google+Sans:wght@400;500;700&display=swap">
    <style>
      * { margin: 0; padding: 0; box-sizing: border-box; }
      body {
        font-family: 'Google Sans', sans-serif;
        color: #fff;
        overflow: hidden;
      }
      #skybox-canvas {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 0;
      }
      #content {
        position: relative;
        z-index: 1;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        min-height: 100vh;
        text-align: center;
        text-shadow: 0 2px 8px rgba(0, 0, 0, 0.7);
      }
      #content canvas, footer canvas {
        max-width: 90vw;
        height: auto;
        image-rendering: pixelated;
        image-rendering: -moz-crisp-edges;
        image-rendering: crisp-edges;
      }
      footer {
        position: fixed;
        bottom: 1rem;
        width: 100%;
        text-align: center;
        z-index: 1;
        font-family: 'Google Sans', sans-serif;
        font-size: 0.85rem;
        color: #fff;
        text-shadow: 1px 1px 2px #000, 0 0 4px rgba(0,0,0,0.5);
        opacity: 0.8;
      }
    </style>

  </head>

  <body>

    <canvas id="skybox-canvas"></canvas>

    <div id="content">
      <canvas id="bmf-title"></canvas>
    </div>

    <footer>
      <p>&copy; 2026 CIC Games<br>ABN 57 409 143 247</p>
    </footer>

    <script src="bmf.js"></script>
    <script type="importmap">
      { "imports": { "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js" } }
    </script>
    <script type="module">
      import * as THREE from 'three';
      import { EffectComposer } from 'https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/postprocessing/EffectComposer.js';
      import { RenderPass } from 'https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/postprocessing/RenderPass.js';
      import { ShaderPass } from 'https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/postprocessing/ShaderPass.js';
      import { OutputPass } from 'https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/postprocessing/OutputPass.js';
      import { GLTFLoader } from 'https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/loaders/GLTFLoader.js';

      const canvas = document.getElementById('skybox-canvas');
      const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);

      const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

      // Skybox scene (hue shifted)
      const skyScene = new THREE.Scene();
      const loader = new THREE.CubeTextureLoader();
      loader.setPath('images/');
      const textureCube = loader.load([
        'right.jpg', 'left.jpg',
        'top.jpg', 'bottom.jpg',
        'front.jpg', 'back.jpg'
      ]);
      skyScene.background = textureCube;

      // Container scene (no hue shift)
      const containerScene = new THREE.Scene();
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
      containerScene.add(ambientLight);
      const dirLight = new THREE.DirectionalLight(0xffeedd, 3.0);
      dirLight.position.set(5, 10, 7);
      containerScene.add(dirLight);
      const fillLight = new THREE.DirectionalLight(0x8899bb, 1.5);
      fillLight.position.set(-5, -3, -5);
      containerScene.add(fillLight);

      // Load and scatter shipping containers
      const containers = [];
      const gltfLoader = new GLTFLoader();
      gltfLoader.load('gltf/Cargo Container.gltf', (gltf) => {
        const template = gltf.scene;
        const count = 30;
        for (let i = 0; i < count; i++) {
          const instance = template.clone();
          const hue = Math.random();
          instance.traverse((child) => {
            if (child.isMesh) {
              child.material = child.material.clone();
              child.material.color.setHSL(hue, 0.8, 0.55);
            }
          });
          const dist = 30 + Math.random() * 170;
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.acos(2 * Math.random() - 1);
          instance.position.set(
            dist * Math.sin(phi) * Math.cos(theta),
            dist * Math.sin(phi) * Math.sin(theta),
            dist * Math.cos(phi)
          );
          instance.scale.set(0.01, 0.01, 0.01);
          instance.rotation.set(
            Math.random() * Math.PI * 2,
            Math.random() * Math.PI * 2,
            Math.random() * Math.PI * 2
          );
          instance.userData.tumble = new THREE.Vector3(
            (Math.random() - 0.5) * 0.005,
            (Math.random() - 0.5) * 0.005,
            (Math.random() - 0.5) * 0.005
          );
          containerScene.add(instance);
          containers.push(instance);
        }
      });

      const hueShader = {
        uniforms: { tDiffuse: { value: null }, uHue: { value: 0.0 } },
        vertexShader: `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }`,
        fragmentShader: `
          uniform sampler2D tDiffuse;
          uniform float uHue;
          varying vec2 vUv;
          vec3 rgb2hsl(vec3 c) {
            float mx = max(c.r, max(c.g, c.b)), mn = min(c.r, min(c.g, c.b));
            float l = (mx + mn) * 0.5, s = 0.0, h = 0.0;
            if (mx != mn) {
              float d = mx - mn;
              s = l > 0.5 ? d / (2.0 - mx - mn) : d / (mx + mn);
              if (mx == c.r) h = (c.g - c.b) / d + (c.g < c.b ? 6.0 : 0.0);
              else if (mx == c.g) h = (c.b - c.r) / d + 2.0;
              else h = (c.r - c.g) / d + 4.0;
              h /= 6.0;
            }
            return vec3(h, s, l);
          }
          float hue2rgb(float p, float q, float t) {
            if (t < 0.0) t += 1.0; if (t > 1.0) t -= 1.0;
            if (t < 1.0/6.0) return p + (q - p) * 6.0 * t;
            if (t < 1.0/2.0) return q;
            if (t < 2.0/3.0) return p + (q - p) * (2.0/3.0 - t) * 6.0;
            return p;
          }
          vec3 hsl2rgb(vec3 c) {
            if (c.y == 0.0) return vec3(c.z);
            float q = c.z < 0.5 ? c.z * (1.0 + c.y) : c.z + c.y - c.z * c.y;
            float p = 2.0 * c.z - q;
            return vec3(hue2rgb(p, q, c.x + 1.0/3.0), hue2rgb(p, q, c.x), hue2rgb(p, q, c.x - 1.0/3.0));
          }
          void main() {
            vec4 tex = texture2D(tDiffuse, vUv);
            vec3 hsl = rgb2hsl(tex.rgb);
            hsl.x = fract(hsl.x + uHue);
            hsl.y = min(hsl.y * 1.15, 1.0);
            hsl.z = min(hsl.z * 1.1, 1.0);
            vec3 rgb = hsl2rgb(hsl);
            rgb = (rgb - 0.5) * 1.01 + 0.5;
            gl_FragColor = vec4(clamp(rgb, 0.0, 1.0), tex.a);
          }
        `
      };

      const composer = new EffectComposer(renderer);
      composer.addPass(new RenderPass(skyScene, camera));
      const huePass = new ShaderPass(hueShader);
      composer.addPass(huePass);
      composer.addPass(new OutputPass());
      renderer.autoClear = false;

      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        composer.setSize(window.innerWidth, window.innerHeight);
      });

      // Random slow rotation direction
      const angle = Math.random() * Math.PI * 2;
      const rotSpeedY = Math.cos(angle) * 0.0005;
      const rotSpeedX = Math.sin(angle) * 0.0005;

      function animate() {
        requestAnimationFrame(animate);
        camera.rotation.y += rotSpeedY;
        camera.rotation.x += rotSpeedX;
        for (const c of containers) {
          c.rotation.x += c.userData.tumble.x;
          c.rotation.y += c.userData.tumble.y;
          c.rotation.z += c.userData.tumble.z;
        }
        huePass.uniforms.uHue.value = (Date.now() * 0.00002) % 1.0;
        renderer.clear();
        composer.render();
        renderer.clearDepth();
        renderer.render(containerScene, camera);
      }
      animate();
    </script>
    <script>
      (async function() {
        const titleCanvas = document.getElementById('bmf-title');

        const titleR = new BMFRenderer(titleCanvas);
        await titleR.loadFont('fonts/Quaked.bmf');

        const shadowOpts = { offsetX: 1, offsetY: 1, color: '#000000' };

        // Title: "CORE64" - scale 12, animated gradient
        const titleText = 'CORE64';
        const titleOpts = { scaleX: 12, scaleY: 12, shadow: shadowOpts, gradient: {
          palette: ['#ff0000', '#ff8800', '#ffff00', '#00ff00', '#00ffff', '#0088ff', '#ff00ff'],
          offset: 0,
        }};
        const titleSize = titleR.measureText(titleText, titleOpts);
        titleCanvas.width = titleSize.width;
        titleCanvas.height = titleSize.height;

        function animateTitle() {
          titleOpts.gradient.offset = (Date.now() * 0.003) % 7;
          titleR.drawText(titleText, 0, 0, titleOpts);
          requestAnimationFrame(animateTitle);
        }
        animateTitle();
      })();
    </script>

  </body>

</html>
